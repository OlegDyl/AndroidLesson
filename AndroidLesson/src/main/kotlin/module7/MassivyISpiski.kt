package module7

import java.util.*
import kotlin.random.Random

fun main() {

/*                                             Массивы и списки

    Цели:
    - Познакомиться с массивами и списками
    - Разобрать на примерах изменяемые и неизменяемые списки
    - Рассмотреть особенности работы со списками и основные операции над ними

    Array
    Массив - это структура данных фиксированного размера, в памяти которой друг за другом хранятся элементы
    одного типа. Это примитивная, базовая коллекция. Все остальные коллекции основываются на массиве.

    - Доступ к элементу по индексу
    - Нельзя изменить размер массива
    - Можно изменять элементы массива

    Последний элемент в массиве - длинна массива - 1

    List
    Список - это структура данных переменного размера, в памяти которой друг за другом хранятся элементы
    одного типа. В отличие от массива размер списков может увеличиваться и уменьшаться.

    Основан на массиве. Может быть изменяемым (mutable) и неизменяемым (immutable).

    Неизменяемый список: List
    Изменяемый список: MutableList

    Для добавления функция add, для удаления remove

    При добавлении происходит следующее - проверка есть ли в текущем списке место для элемента, если нет, то создается
    массив большего размера, а данные из предыдущего массива копируются в новый.

    При удалении элемента из списка происходит следующее - удаляется элемент из списка, все элементы правее удаленного
    сдвигаются в лево и при необходимости можно вызвать функцию дримтусайз для уменьшения размера списка до фактического.

    Для создания неизменяемого списка мы можем воспользоватся двумя способами: через специальную функцию ListOf
  */

    val list = listOf<Int>(1, 2, 3, 4) // специально <Int> можно не указывать, он может быть автоматически вычислен
    val carList = listOf<String>("Mercedes", "BMW", "Ferrari")

    // совершенно точно нужно указывать тип данных, если необходимо создать пустой список с помощью функций listOf или emptyList

    val emptyList = listOf<String>()
    val secondEmptyList = emptyList<String>()

    // Второй способ - это создание списка через функцию конструктор. В этом случае необходимо явно указать размер списка
    // и предоставить лямбда функцию для инициализации каждого элемента списка

    val secondList = List<Int>(5) { 0 }
    val secondCarList = List<String>(3) { index -> "Car №${index}" }

    // Передать конкретные значения в этом случае уже не выйдет. Все что мы можем, это определить лямбда функцию для инициализации
    // заполнить массив строк с помощью функции которая возвращает строчку типа Car № и индекс нашего элемента

    // Для изменяемых списков все то же самое только используются соответсвующее функции mutableListOf и тип MutableList

    val mutableList = mutableListOf<Int>(1, 2, 3, 4)
    val mutableCarList = mutableListOf<String>("Mercedes", "BMW", "Ferrari")

    val mutableSecondList = MutableList<Int>(5) { 0 }
    val mutableSecondCarList = MutableList<String>(3) { index -> "Car №${index}" }

    /* Давайте посмотрим на разницу между изменяемым и неизменяемым списком. В обоих случаях мы можем обратиться к элементу по индексу
    Создадим два одинаковых списка один изменяемый, второй нет*/

     val list2 = listOf(1, 2, 3, 4)
     val mutableList2  = mutableListOf<Int>(1, 2, 3, 4)

    // Давайте изменим второй элемент
    // list2[1] = 4  - тут ошибка, так как в обычном списке нет функций позволяющих изменить элементы
    mutableList2[1] = 4 // изменение второго элемента с 2 на 4
    mutableList2.add(6)
    mutableList2.add(7)

    println(mutableList2) // выводится [1, 4, 3, 4, 6, 7]
    println(mutableList2.size)  // выводиться размер списка 6
    println(mutableList2.joinToString(",")) // выводит элементы списка в строку через указанный символ в скобках , 1,4,3,4,6,7

    // чтобы обратиться к последнему элементу Kotlin предоставляет специальное свойство lastIndex

    println(list[list2.lastIndex])

    // Что касается циклов, то со списками удобно работать. Например, цикл for. Давайте пройдем по списку и выведем число умноженное на его порядковый номер

    for (i in list2.indices){
        println(list2[i] * i)
    }

    // функция высшего порядка forEach которая принимает в себя лямбда выражение или другую функцию, которая описывает какие операции нужно сделать с каждым элементом списка

    list2.forEach { item -> println(item) }
    
    list2.forEachIndexed { index, item  ->
        println(item * index)
    }

   /* item - это ключевое слово, которое используется для итерации по элементам коллекций. Например, в следующем коде мы можем использовать item для итерации по элементам списка:

    val list = listOf("apple", "banana", "orange")
    for (item in list) {
        println(item)
    }

    Итерация по элементам списка - это процесс перебора всех элементов списка. В языке программирования Kotlin
    для итерации по элементам списка используется цикл for. В каждой итерации цикла мы можем обращаться к текущему
    элементу списка с помощью ключевого слова item. Например, в следующем коде мы можем использовать цикл for, чтобы
    перебрать все элементы списка:

val list = listOf("apple", "banana", "orange")
for (item in list) {
    println(item)
}

В этом коде мы создали список строк и затем использовали цикл for, чтобы перебрать все элементы списка.
В каждой итерации мы можем обращаться к текущему элементу списка с помощью ключевого слова item*/


    println(list2.sumBy { it * 5 }) //функция sumBy считает сумму основываясь на правиле которое передает лямбда выражение. В нашем случае сумма всех элементов умноженных на 5
    println(carList.sumBy { it.length }) // в этом случае подсчитывает количество символов


    /* Часто встречается задача удалить из списка все элементы которые удовлетворяют какому-то правилу.
    Решим подобную задачу: создадим изменяемый список который заполним случайными значениями от - 10 до 10 с помощью функции Random.nextInt(-10, 10).
    Задача в следующем удалить из массива все элементы, которые меньше 0.       */

    /*val numbers = MutableList(10) { Random.nextInt(-10, 10)}
    println(numbers)
    numbers.forEach {
        if(it < 0)
            numbers.remove(it)
    }
    println(numbers)
*/


/*    val numbers = MutableList(10) { Random.nextInt(-10, 10)}
    println(numbers)
    val candidatesToRemove = mutableListOf<Int>()
    numbers.forEach {
        if(it < 0)
            candidatesToRemove.add(it) // добавляем в candidatesToRemove все что меньше 0
    }
    numbers.removeALL(candidatesToRemove) // удаляем candidatesToRemove и так же удаляем из первоначального списка
    println(numbers)*/


    // removeAll - это функция, которая принимает в себя правило по которому будут удаляться

    val numbers = MutableList(10) { Random.nextInt(-10, 10)}
    println(numbers)
    numbers.removeAll{ it < 0} // удаляет из списка все что меньше 0
    println(numbers)


    // Рассмотрим еще несколько полезных функций. Преобразование неизменяемого списка в изменяемый и обратно

    val list3 = listOf(1, 2, 3, 4, 5)
    val mutableList3 = list.toMutableList() // преобразовали в изменяемый

    mutableList.toList() // опять преобразовали в неизменяемый

    // нужно помнить что эти функции создают лишь копию списка, который можно либо нельзя изменять

    // Функция преобразования списка из одного типа в другой тип с помощью функции map

    val stringList = list.map { // преобразовали числа в строки
        "This was a number $it"
    }
    stringList.forEach { println(it) }

    val mutableStringList = stringList.toMutableList() //преобразовали в изменяемый
    mutableStringList.add("new string")

    mutableStringList.forEach { println(it) }



    /*                                 Коллекции, основанные на списках и массивах

    Связный список - список, в котором каждый элемент имеет ссылки на предыдущий и следующий элементы.

    - операции добавления и удаления происходят быстрее
    - получение и изменение элемента происходит медленнее


    Queue
    Очередь - структура данных, работающая по принципу First In - First Out (первый вошел - первый вышел).
    Элементы добавляются в конец очереди, а извлекаются из ее начала. Пример очередь в магазин


    Stack
    Стек - структура данных, работающая по принципу Last In - First Out (последний вошел - первый вышел). Пример стопка книг.





    */



}

