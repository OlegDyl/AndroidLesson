package module7

import java.util.TreeSet

fun main() {


    /*Преставления и множества


       Задачи:
       - рассмотреть их реализации
       - рассмотреть особенности работы с ними и основные операции над ними


    Представления, ассоциативный массив, словарь - структура данных, которая хранит элементы в виде пар ключ-значение.
    Ключи уникальные, а значения могут дублироваться. Для разных ключей можно хранить одно и то же значение.

    Основные реализации: HashMap, LinkedHashMap, TreeMap

    HashMap
    - основана на хеш-таблице. Элементы хеш-таблицы представляют собой пары ключ-значение
    - порядок элементов основан на результате хеш-функций ключа
    - используется функция equals для сравнения ключей
    - используется функция hashCode для расчета хеш-кода ключа
    - Возможны коллизии при одинаковых еш-кодах различных ключей


    LinkedHashMap
    - расширяет функцию HashMap
    - элементы LinkedHashMap имеют ссылки на соседние элементы
    - Сохраняется порядок добавления элементов

    TreeMap
    TreeMap - это коллекция, хранящая пары ключ-значение, которые отсортированы по значению ключа.

    - основана на структуре данных красно-черное дерево
    - элементы имеют ссылки на не более чем 2 других элемента ниже по иерархии
    - обеспечивают сортировку в натуральном порядке по умолчанию
    - возможна пользовательская сортировка
   */

    val map = mapOf<Int, String>(
        1 to "2",
        Pair(2, "123")
    )  // инициализация map похожа на инициализацию массивов. Для каждой реализации map есть своя функция котоая ее создает mapOf, hashMapOf, sortedMapOf, sortedMapOf
    val hashMap = hashMapOf(1 to "one", 2 to "two", 3 to "three")
    val treeMap = sortedMapOf(1 to "one")
    val linkedHashMap = linkedMapOf<Int, Int>()
    // нужно пердостовлять в функцию списки пар ввиде (ключ to значение) либо через явное создание типа Pair ( Pair(2, "123")).
    // Важное отличие в том что список работает с одним типом данных map же работает с двумя типами данных: типом ключа и типом данных
    // Они могут быть разными, могут быть одинаковыми
    // В отличии от списков у предстовлений нет отдельных типов для изменяемой и неизменяемой коллекции, вместо этого ответственность лежит на интерфейсах
    // По умолчанию они создаются изменяемыми, а вот вызов общей функции mapOf даст как раз неизменяемую коллекцию которая содержит пары ключ значение в порядке их добавления
    val mutableMap =
        mutableMapOf<Int, String>() // функция mutableMapOf создаст изменяемую коллекцию которое содержит пары ключ - значение, но не обладает свойствами hashMap или linkedHashMap

    // map [222] = "1234"
    hashMap[222] = "1234"
    treeMap[222] = "1234"
    linkedHashMap[222] = 1234

    // Напишем небольшую программу чтобы наглядно продемонстрировать работу с представлениями. Сделаем таблицу стоимости
    // товаров в магазине ключем в этой таблице будет выступать название товара типа String, а значением его цена.
    // Создадим изменяемую map и заполним парами

    val priceList = mutableMapOf<String, Int>(
        "Milk" to 80,
        "Yogurt" to 50,
        "Apples" to 150,
        "Bananas" to 70,
        "Coco-cola" to 100,
        "Orange juice" to 150
    )
    println(priceList) // вывелось {Milk=80, Yogurt=50, Apples=150, Bananas=70, Coco-cola=100, Orange juice=150}


    // теперь создадим оналогичные map с помощью функций hashMapOf и sortedMapOf

    val priceListHash = hashMapOf<String, Int>(
        "Milk" to 80,
        "Yogurt" to 50,
        "Apples" to 150,
        "Bananas" to 70,
        "Coco-cola" to 100,
        "Orange juice" to 150
    )

    val priceListSorted = sortedMapOf<String, Int>(  // Для sortedMapOf ключи расположены по алфавиту
        "Milk" to 80,
        "Yogurt" to 50,
        "Apples" to 150,
        "Bananas" to 70,
        "Coco-cola" to 100,
        "Orange juice" to 150
    )
    println(priceListHash) //вывелось {Apples=150, Coco-cola=100, Bananas=70, Orange juice=150, Yogurt=50, Milk=80}
    println(priceListSorted) // вывелось {Apples=150, Bananas=70, Coco-cola=100, Milk=80, Orange juice=150, Yogurt=50}


    // чтобы добавить элемент в таблицу просто необходимо обратиться к нему по ключу и присвоить какое-то значение,
    // если такого ключа еще нет, то он будет создан, соответственно будет присвоено значение, если такой ключ уже есть,
    // то значение по этому ключу будет присвоено новое

    priceListSorted["Ice cream"] = 75 // добавили новый элемент Ice cream=75
    priceListSorted["Milk"] = 90 // Milk теперь равен 90
    println(priceListSorted)

    // Для удаления значения из таблиыц необходимо вызвать функцию remove() и передать туда значения ключа.
    // Если такой ключ будет найден, то запись будет удалена, если нет, то ничего не произойдет

    priceListSorted.remove("Yogurt")
    println(priceListSorted)

    // Можем запросить у нашей таблицы все ключи, чтобы в дальнейшем их как-то обработать
    println(priceListSorted.keys) // вывелись отдельно ключи [Apples, Bananas, Coco-cola, Ice cream, Milk, Orange juice]

    // Аналогично со значениями. Например, мы можем найти максимальную стоимость товара в нашей таблице
    println(priceListSorted.values.maxOrNull()) // вывелось 150

    // Так же доступен поиск по значению. Например, найдем товар с сомой большой стоимостью
    val maxValue = priceListSorted.values.maxOrNull()
    println(priceListSorted.filterValues { it == maxValue }) // все с максимальным значениям. Вывелись {Apples=150, Orange juice=150}

    // Циклы для map будут выглядеть следующим образом

    for (entry in priceListSorted.entries) { // в этом цикле мы проходим по всем элементам находящимся в списке элементов.
    // Мы можем обработать каждую из этих entries следующим образом разделим ключ значение на два отдельных объекта и выедим их с помощью строкового шаблона
        println("${entry.key} - ${entry.value}")
    }
    /*выводиться:
    Apples - 150
    Bananas - 70
    Coco-cola - 100
    Ice cream - 75
    Milk - 90
    Orange juice - 150*/


    // аналогично для цикла forEach

    priceListSorted.forEach{ entry ->
        println("${entry.key} - ${entry.value}")
    }

    // в forEach допустимо и так:
    priceListSorted.forEach{ (key, value) ->
        println("$key - $value")
    }

  /*  for (entry in ..) - это цикл for, который используется для итерации по элементам коллекции.
   В Kotlin вы можете использовать цикл for для итерации по любому объекту, который реализует интерфейс Iterable.
    Внутри цикла вы можете получить доступ к текущему элементу с помощью переменной entry. Например:

    val list = listOf("a", "b", "c")
    for (entry in list) {
        println(entry)
    }
    Копировать
    В этом примере мы создаем список строк и используем цикл for, чтобы вывести каждый элемент списка на консоль.*/

    val sortedMap = priceList.toSortedMap()  // преобразование коллекции в SortedMap. Ключи сортируются по алфавиту
    println(sortedMap)

  /*  Функция toSortedMap() в Kotlin используется для преобразования карты в отсортированную карту.
    Результирующая отсортированная карта определяет равенство и порядок ключей в соответствии с их естественным
    порядком сортировки. По умолчанию функция сортирует ключи в порядке возрастания. Если вы хотите отсортировать
    их в порядке убывания, вы можете использовать функцию toSortedMap(reverseOrder()) .*/

    // для сортировки как хотим мы необходимо в функцию toSortedMap() передать compareBy {}  в которой указать лямбда
    // выражение которое будет использоваться для сортировки элементов. Все элементы сортируются по ключам. Пример сортировки по длине ключа

    val sortedMap2 = priceList.toSortedMap(compareBy { it.length }) // compareBy если встречает несколько элементов
    // одновременно удовлетворяющих правилу, оставляет в результате только последнее(в нашем случае есть несколько ключей с одинаковым количеством символов)
    println(sortedMap2)

    // чтобы сохранить в данном случае все элементы необходимо добавить thenBy { it }

    val sortedMap3 = priceList.toSortedMap(compareBy<String> { it.length }.thenBy{ it })
    println(sortedMap3)


   /* Set
    Множество - структура данных, которая хранит набор уникальных значений.

    Основные реализации:

    -HashSet использует HashMap для организации данных.
    Не гарантирует порядок данных

    -LinkedHashSet использует LinkedHashMap для организации данных.
    Данные хранятся в порядке добавления

    -TreeSet использует TreeMap для организации данных.
    Данные отсортированы в натуральном порядке по умолчанию

    */

    val set = setOf(1, 2, 2, 3, 1, 2)  // setOf неизменяемое множество, остальные изменяемое
    val hashSet = hashSetOf(1, 2, 3, 3, 2, 1)
    val sortedSet = sortedSetOf(1, 2, 3, 3, 2, 1).toSet()  //Эта строка кода создает отсортированный набор из списка чисел [1, 2, 3, 3, 2, 1],
   // удаляет дубликаты и преобразует его в набор1. В результате получается набор {1, 2, 3}
    val linkedSet = linkedSetOf(1, 2, 3, 3, 2, 1)

    val hasSet2 = HashSet<String>()
    val sortedSet2 = TreeSet<String>()
    val linkedSet2 = LinkedHashSet<String>()

    // Имея несколько множеств мы можем различным образом их комбинировать. Результатом сложения будет множество содержащее
    // все элементы из обоих подмножеств, результатом вычитания будет множество содержащее элементы первого множества, но
    // которые не встречаются во втором. Результатом пересечения будет множество которое содержит элементы встречающиеся
    // в обоих множествах.
    // Проилюстрируем это на примере: представим, что у нас есть город который разделен рекой в этом городе есть автобусы
    // на каждой половине ходит свой набор автобусов, но при этом некоторые маршруты могут перевозить пассажиров с одной
    // части города на другую часть через реку. С помощью множеств мы сможем найти номера автобусов, которые ходят только
    // по своим частям города и автобусы которые могут перевезти пассажиров на другую часть города

    val northBusSet = setOf(1, 4, 5, 6, 12, 13, 16, 19, 20) // автобусы, которые ходят по северной части города
    val southBusSet = setOf(1, 2, 3, 7, 4, 5, 6, 7, 8, 16, 19, 20, 31) //  автобусы, которые ходят по южной части города

    val onlyNorthBus = northBusSet.subtract(southBusSet) // автобусы, которые ходят только по северу - вычитаем из северных южные автобусы
    val onlySouthBus = southBusSet.subtract(northBusSet) // автобусы, которые ходят только по югу
    val globalBus = northBusSet.intersect(southBusSet) // Функция пересечения множеств. Мы видим какие автобусы ходят по обеим частям города

    // Все остальные операции, такие как добавления, удаления, поиск преобразование к другому типу и тд. Анологичны
    // соответвсующим оперрациям представлений с поправкой на свойство множеств(наличие только уникальных элементов и отсутвие
    // явного ключа), а так же из-за отсутсвие явного ключа сортировка в том числе и пользовательская происходит по значениям
    // с не явным использованием функции equals()



}