package nasledovanie

fun main() {

                                            /*Наследование

    Цели:
    - Узнать о принципе наследования в ООП

    Наследование - механизм, который позволяет описывать новый класс на основе уже имеющегося, взяв за основу все методы
    и поля этого класса.
    Класс, который взят за основу, называют базовым, родительским, предком или суперклассом.
    Класс на его основе называют потомком, наследником, дочерним или производным классом.
    Производный класс обладает всеми теми же свойствами, что и базовый класс, а также может иметь свои собственные поля
    и функции.

    Для чего нужно наследование:
    - описывать иерархии классов, структурировать и систематизировать классы
    - переиспользовать уже написанный код и избегать ненужного дублирования или копирования кода
    - основа для полиморфизма

    Механизм наследования реализует отношение "is - a"(является) между производным и базовым классом:
    - экземпляр производного класса является экземпляром базового
    - экземпляр базового класса не является экземпляром производного класса

    Создадим Class Person

    для того чтобы унаследовать класс от другого, нужно поставить двоеточие
    после первичного конструктора класса, а если его нет, то после имени класса и указать от какого класса мы хотим
    наследоваться class Driver : Person.


                                        Наследование
    Правила наследования:
    - наследоваться можно только от открытых классов. Чтобы сделать класс открытым, необходимо установить ему модификатор
    open. По умолчанию в Kotlin все классы закрыты для наследования

    - если у производного класса есть первичный конструктор, то базовый класс должен быть проинициализирован в оглавлении
    класса. Если первичного конструктора нет, то все дополнительные конструкторы должны явно указывать один из конструкторов
    базового класса с помощью ключевого класса super


    Создадим экземпляр обоих классов Person и Drive
*/

    val person = Person("Alex", 25)
    val drive = Driver("Ivan", 46, 2)

    // для класса Person мы можем вызвать
    person.age
    person.name
    person.sleep()
    person.eat()
    person.walk()

    // все тоже самое мы можем вызвать и для driver
    drive.age
    drive.name
    drive.sleep()
    drive.eat()
    drive.walk()
    // помимо этого можно обратиться к членам класса Driver, в то же время у person нет таких полей и функции drive()
    drive.experience
    drive.drive()

    // Механизм наследования позволяет получать не только доступ к членам базового класса, но и изменять или модифицировать,
    // переопределять поля и функции базового класса


    // Рассмотрим еще один пример и создадим иерархию классов для описания программиста, за основу возьмем class Person,
    // создадим класс Developer, унаследуем его от класса человек, объявим в нем дополнительное поле - опыт и две
    // функции: писать код и узнать позицию.

    // создадим еще несколько классов программистов которые пишут на конкретном языке

    // Рассмотрим вариант с дополнительными конструкторами, для правильного наследования нам все еше необходимо
    // указывать родительский класс и передавать в его конструктор все необходимые аргументы, для этого в дополнительном
    // конструкторе класса KotlinDeveloper(вызывается constructor)
    // constructor(name: String, age: Int) : super(name, age)   -    этот пример в KotlinDeveloper


    val ktDev = KotlinDeveloper("Alex", 25)
    val javaDev = JavaDeveloper(name = "Ivan", age = 40, exception = 20)
    val cppDev = CppDeveloper(name = "Anna", age = 30, exception = 7)
    val developer = Developer(name = "MegaMozg", age = 100, experience = 100)

    ktDev.writeCode()
    println("ktDev level - ${ktDev.getLevel()}")
    println("experience - ${ktDev.experience}")

    javaDev.writeCode()
    println("java level - ${javaDev.getLevel()}")
    println("experience - ${javaDev.experience}")

    cppDev.writeCode()
    println("cppDev level - ${cppDev.getLevel()}")
    println("experience - ${cppDev.experience}")

    developer.writeCode()
    println("cppDev level - ${developer.getLevel()}")
    println("experience - ${developer.experience}")

    // Для того чтобы в нашей программе установить каждому программисту свой язык программирования, переопределим
    // функция writeCode(), для этого необходимо указать override и функцию, которую хотим переписать, но переопределять
    // можно только открытые функции


    // ovverride val paradigm = "functional" // так мы переопределяем переменную из другого класса

    // open мы помечаем если хотим изменить

    // в классе CppDeveloper подправим функцию для расчета опыта программиста


}